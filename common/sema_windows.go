// go build mksyscall_windows.go && ./mksyscall_windows event.go eventlog.go registry.go security.go service.go syscall.go
// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT

package common

import (
	"syscall"
	"unsafe"
)

var modkernel32 = syscall.NewLazyDLL("Kernel32.dll")

func CreateSema(initNum uint32, maxNum uint32, name *uint16) (handle syscall.Handle, err error) {
	procCreateSemaphore := modkernel32.NewProc("CreateSemaphoreA")
	r1, _, e1 := syscall.Syscall6(procCreateSemaphore.Addr(),
		4,
		uintptr(unsafe.Pointer(nil)),
		uintptr(initNum),
		uintptr(maxNum),
		uintptr(unsafe.Pointer(name)), 0, 0)
	handle = syscall.Handle(r1)
	if handle == 0 {
		if e1 != 0 {
			err = e1
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetLastError() uint32 {
	procGetLastError := modkernel32.NewProc("GetLastError")
	ret, _, _ := procGetLastError.Call()
	return uint32(ret)
}

func ReleaseSema(handle syscall.Handle, num uint32) (err error) {
	procReleaseSemaphore := modkernel32.NewProc("ReleaseSemaphore")
	r1, _, e1 := procReleaseSemaphore.Call(uintptr(handle), uintptr(num), 0)
	if r1 == 0 {
		if e1 != nil {
			err = e1
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func WaitForSingleObject(handle syscall.Handle, mode uint32) (err error) {
	procWait := modkernel32.NewProc("WaitForSingleObject")
	r1, _, e1 := procWait.Call(uintptr(handle), uintptr(mode))
	if r1 == 0 {
		if e1 != nil {
			err = e1
		} else {
			err = syscall.EINVAL
		}
	}
	return
}
